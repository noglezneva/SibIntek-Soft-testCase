# Задание 1. 
# Ответьте на вопросы:

# 1.1. Что такое goroutine в Go и как она отличается от традиционного потока?

Ответ: 
Goroutine в Go это легковесная однопоточная функция, которая выполняется параллельно с другими горутинами. Отличие горутин от традиционных потоков заключается в их создании и управлении. Создание горутин требует меньше ресурсов, чем создание потока операционной системы, и Go-рантайм самостоятельно планирует выполнение горутин на доступных потоках.

# 1.2. Что такое каналы в Go? Что будет возвращено при чтении из закрытого канала?

Ответ: 
Каналы в Go представляют собой специальный тип данных, который используется для обмена информацией между горутинами. Каналы имеют тип данных, который определяет тип передаваемых через них значений. При чтении из закрытого канала будет возвращено нулевое значение для типа данных канала. Если канал типизирован, то будет возвращен нулевое значение соответствующего типа.

# 1.3. Как в Go реализовать взаимное исключение при доступе к общим ресурсам?

Ответ: 
В Go взаимное исключение при доступе к общим ресурсам можно реализовать с помощью мьютексов (mutex). Мьютексы позволяют заблокировать доступ к общему ресурсу перед его использованием и разблокировать после завершения операции. Это гарантирует, что только одна горутина может получить доступ к общему ресурсу одновременно.

Пример:
```go
package main

import (
	"fmt"
	"sync"
)

var (
	counter int
	mutex   sync.Mutex
)

func increment() {
	mutex.Lock()
	defer mutex.Unlock()

	counter++
}

func main() {
	var wg sync.WaitGroup
	numRoutines := 10

	wg.Add(numRoutines)
	for i := 0; i < numRoutines; i++ {
		go func() {
			defer wg.Done()
			increment()
		}()
	}

	wg.Wait()

	fmt.Println(counter)
}
```
В этом примере у нас есть общая переменная counter, к которой несколько горутин одновременно пытаются получить доступ и инкрементировать ее значение. Мьютекс mutex используется для синхронизации доступа к переменной counter. Функция increment блокирует мьютекс с помощью mutex.Lock(), чтобы гарантировать, что только одна горутина может одновременно изменять counter. После внесения изменений мьютекс освобождается с помощью mutex.Unlock().

# 1.4. Что такое ананимная функция в Go?

Ответ: 
Анонимная функция в Go это функция, которая не имеет имени. Она может быть определена и немедленно вызвана (self-executing anonymous function) или присвоена переменной и вызвана позднее. Анонимные функции полезны, когда требуется определить небольшую функцию на месте без необходимости дать ей имя.

# 1.5. Как в Go обрабатывать паники и ошибки?

Ответ:
В Go паники и ошибки обрабатываются с помощью механизмов паник (panic) и восстановления (recovery).
Когда происходит паника, выполнение программы останавливается, и в стеке вызовов начинается процесс восстановления, чтобы обработать панику и вернуться к нормальному выполнению программы.
Ошибки в Go часто представлены с помощью типа error, который является встроенным интерфейсом в Go. Возвращение ошибок из функций является общим практическим подходом для обработки ошибок в Go.

Пример:
```go
func main() {
   defer func() {
      if r := recover(); r != nil {
         log.Printf("Panic occurred: %v", r)
         // Дополнительная обработка паники
      }
   }()

   // Код, который может вызвать панику
}
```
В этом примере обработчик паники внутри функции defer использует функцию recover, чтобы перехватить панику и выполнить дополнительную обработку.
Обработка паник и ошибок зависит от конкретной ситуации и требований приложения. Для более сложных сценариев может потребоваться более детальная обработка и восстановление паник, а также более точная обработка и логирование ошибок.

# 1.6. Существует ли концепция наследования в Go?

Ответ:
В кассическом понимании - отсутствует, но, вместо наследования Go предлагает композицию и интерфейсы для достижения похожих целей. С помощью композиции можно создавать новые типы, включающие в себя другие типы, а интерфейсы позволяют определить набор методов, которые должны быть реализованы в конкретном типе.

# 1.7. Что такое интерфейсы в Go?

Ответ:
Интерфейс – это набор сигнатур методов, которые надо реализовать, чтобы удовлетворить контракту (описывают поведение объекта, которое мы от него ожидаем). Чтобы тип удовлетворял интерфейсу в go, не нужно явно объявлять, что он реализует интерфейс, вместо этого нужно имплементировать все методы, определенные в интерфейсе.
Одному интерфейсу может соответствовать множество типов. Тип может реализовать несколько интерфейсов. Переменная типа интерфейс может содержать значение типа, реализующего этот интерфейс

Под капотом: 
Интерфейс – это структура, содержащая 2 поля: 
1) data unsafe.Pointer(Хранимые данные) значения
2) tab *itab (информация об интерфейсе) – указатель на интерфейсную таблицу interface table
Интерфейсная таблица – это тоже структура, ее основной задачей является то, что она содержит список методов, определенных в интерфейсах. Когда мы определяем интерфейс, для каждого метода интерфейса создается запись в интерфейсной таблице. Эта запись включает в себя информацию о сигнатуре метода и указатель на соответствующую функцию в структуре или типе данных, который реализует данных интерфейс.

При вызове метода через интерфейс, go использует таблицу интерфейса для определения соответствующей функции для вызова. 

# 1.8. Что такое "грязное чтение" (dirty read) в контексте баз данных?

Ответ: 
"Грязное чтение" (dirty read) в контексте баз данных означает чтение неподтвержденных или нестабильных данных. Это может произойти, когда одна транзакция читает данные, которые были изменены другой транзакцией, но еще не были подтверждены. В результате чтения таких "грязных" данных возникает возможность получить некорректную информацию.